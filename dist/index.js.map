{
  "version": 3,
  "sources": ["../cssplus.ts"],
  "sourcesContent": ["export const SETTINGS = {\n  DEBUG: false,\n};\n\nfunction eatWhitespace(input: string, start: number) {\n  while (/\\s/.test(input[start])) {\n    start++;\n  }\n\n  // Eat comments\n  if (input[start] === '/' && input[start + 1] === '*') {\n    // Skip past /*\n    start += 2;\n    while (!(input[start] === '*' && input[start + 1] === '/')) {\n      start++;\n    }\n    // Skip past */\n    start += 2;\n  }\n\n  while (/\\s/.test(input[start])) {\n    start++;\n  }\n\n  return start;\n}\n\nfunction debug(msg: string, ...rest: Array<any>) {\n  if (SETTINGS.DEBUG) {\n    console.log('[Debug] ' + msg, ...rest);\n  }\n}\n\nfunction guard(input: string, i: number, msg: string) {\n  debug(msg);\n  if (input[i] === undefined) {\n    throw new Error(msg + ' failed');\n  }\n}\n\nfunction parseToken(\n  input: string,\n  i: number,\n  endMarker: Array<string>\n): [string, number] {\n  let token = '';\n  i = eatWhitespace(input, i);\n  while (!endMarker.includes(input[i])) {\n    guard(input, i, 'Waiting for ' + JSON.stringify(endMarker));\n    if (input[i] === \"'\") {\n      token += input[i];\n      i++;\n      while (input[i] !== \"'\") {\n        guard(input, i, 'Waiting for closing single quote');\n        token += input[i];\n        i++;\n      }\n    } else if (input[i] === '\"') {\n      token += input[i];\n      i++;\n      while (input[i] !== '\"') {\n        guard(input, i, 'Waiting for closing double quote');\n        token += input[i];\n        i++;\n      }\n    } else if (input[i] === '[') {\n      token += input[i];\n      i++;\n      while (input[i] !== ']') {\n        guard(input, i, 'Waiting for closing bracket');\n        token += input[i];\n        i++;\n      }\n    }\n    token += input[i];\n    i++;\n  }\n\n  return [token.trim(), i];\n}\n\nexport interface Declaration {\n  type: 'declaration';\n  property: string;\n  value: string;\n}\n\nexport interface Rule {\n  type: 'rule';\n  selectors: Array<string>;\n  declarations: Array<Declaration | Rule>;\n}\n\nfunction parseRule(input: string, i: number): [Rule, number] {\n  let token = '';\n  let rule: Rule = { selectors: [], declarations: [], type: 'rule' };\n\n  guard(input, i, 'Waiting for EOL');\n\n  i = eatWhitespace(input, i);\n\n  let prev = ',';\n  while (true) {\n    guard(input, i, 'Waiting for comma');\n    [token, i] = parseToken(input, i, ['{', ',']);\n    rule.selectors.push(token);\n\n    i = eatWhitespace(input, i);\n    prev = input[i];\n    if (prev === '{') {\n      break;\n    }\n    i++; // Skip past ,\n  }\n\n  i++; // Skip past {\n\n  while (input[i] !== '}') {\n    guard(input, i, 'Waiting for closing brace');\n    const declaration: Declaration = {\n      type: 'declaration',\n      property: '',\n      value: '',\n    };\n    i = eatWhitespace(input, i);\n\n    const possibleInnerDeclarationStartingPoint = i;\n    token = '';\n    let foundInner = false;\n    while (input[i] !== ':') {\n      guard(\n        input,\n        i,\n        'Waiting for colon ' +\n          (rule.declarations.length > 0\n            ? 'after ' +\n              JSON.stringify(\n                rule.declarations[rule.declarations.length - 1],\n                null,\n                2\n              )\n            : 'after first declaration')\n      );\n\n      if (input[i] === '{') {\n        const [nested, newI] = parseRule(\n          input,\n          possibleInnerDeclarationStartingPoint\n        );\n        rule.declarations.push(nested);\n        i = newI;\n        foundInner = true;\n        break;\n      } else {\n        token += input[i];\n        i++;\n      }\n    }\n\n    if (foundInner) {\n      i = eatWhitespace(input, i);\n      continue;\n    }\n\n    i++; // Skip past :\n\n    declaration.property = token.trim();\n\n    i = eatWhitespace(input, i);\n\n    [token, i] = parseToken(input, i, [';']);\n\n    i++; // Skip past ;\n\n    declaration.value = token.trim();\n\n    rule.declarations.push(declaration);\n    debug('Found declaration', declaration);\n\n    i = eatWhitespace(input, i);\n  }\n\n  i++; // Skip past }\n\n  debug('Found rule', rule);\n  return [rule, i];\n}\n\nfunction parse(input: string, i = 0) {\n  const rules: Rule[] = [];\n  while (i < input.length) {\n    i = eatWhitespace(input, i);\n    const [rule, newI] = parseRule(input, i);\n    rules.push(rule);\n    i = eatWhitespace(input, newI);\n  }\n\n  return rules;\n}\n\nfunction cartesian(...a: string[][]): string[][] {\n  return a.reduce(\n    (a, b) =>\n      a.map((x) => b.map((y) => x.concat(y))).reduce((c, d) => c.concat(d), []),\n    [[]] as string[][]\n  );\n}\n\nfunction flatten(rules: Rule[]) {\n  for (let i = 0; i < rules.length; i++) {\n    const rule = rules[i];\n\n    rule.declarations.forEach(function flattenDecl(decl, di) {\n      if (decl.type === 'rule' && !rule.selectors[0].startsWith('@')) {\n        // Handle multiple-y nested rules\n        const childRules = [decl];\n        flatten(childRules);\n\n        childRules.forEach(function flattenChild(cr, j) {\n          // Insert into global rules after this one with correct selector\n          rules.splice(i + 1, 0, {\n            ...cr,\n            selectors: cartesian(rule.selectors, cr.selectors).map((inner) =>\n              inner.join(' ')\n            ),\n          });\n        });\n\n        i++; // Skip past added rule\n\n        // Remove from here\n        rule.declarations.splice(di, 1);\n      }\n    });\n  }\n}\n\nfunction write(rules: Rule[], indent = '') {\n  const out: string[] = [];\n  rules.forEach(function writeRule(rule) {\n    if (rule.declarations.length === 0) {\n      return;\n    }\n\n    const declarations = [indent + rule.selectors.join(',\\n') + ' {'];\n\n    rule.declarations.forEach(function writeDecl(decl) {\n      if (decl.type === 'rule') {\n        const rules = write([decl], indent + '  ');\n        declarations.push(rules);\n      } else {\n        declarations.push(\n          indent + '  ' + decl.property + ': ' + decl.value + ';'\n        );\n      }\n    });\n\n    declarations.push(indent + '}');\n\n    out.push(declarations.join('\\n'));\n  });\n\n  return out.join('\\n\\n');\n}\n\nexport function transform(cssp: string) {\n  const rules = parse(cssp);\n  flatten(rules);\n  return write(rules);\n}\n"],
  "mappings": "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",
  "names": []
}
